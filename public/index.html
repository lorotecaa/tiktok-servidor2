|<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Subasta en Vivo</title>
    <style>
        /* ESTILOS BASE DEL DASHBOARD (INTACTO) */
        body { font-family: Arial, sans-serif; background: #111; color: white; text-align: center; margin:0; padding:0; display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; }
        h1 { margin:20px 0; }
        ul { list-style: none; padding: 0; }
        li { margin: 5px 0; font-size: 18px; }
        .totales { margin-top: 10px; font-weight: bold; font-size: 16px; }
        h2 { background: rgba(255,255,255,0.15); padding: 4px 8px; border-radius: 5px; display: inline-block; margin-bottom: 10px; font-size: 18px; }
        button { margin: 5px; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; }
        .start { background: green; color: white; }
        .stop { background: red; color: white; }
        #logDonaciones { background: #333; color: #ccc; width: 740px; height: 150px; overflow-y: auto; margin: 20px auto; padding: 10px; border-radius: 10px; text-align: left; font-family: monospace; }
        
        /* CONTENEDORES PRINCIPALES (MODO DASHBOARD: TRES COLUMNAS) (INTACTO) */
        /* Nota: Se han aÃ±adido los IDs 'ganadores' y 'participantes' a los divs principales abajo. */
        #ganadores, #participantes, #controles-group { 
    margin: 20px; 
    padding: 20px; 
    border-radius: 10px; 
    display: inline-block; 
    vertical-align: top; 
}
#ganadores { background: #2c3e50; width: 350px; height: 400px; overflow-y: auto; }
#participantes { background: #27ae60; width: 350px; height: 400px; overflow-y: auto; }
#controles-group { 
    width: 300px; 
    padding: 0; 
    margin: 20px 40px 20px 20px; /* Incrementa el margen derecho a 40px */
    display: inline-block; 
    vertical-align: top; 
}
        #controles { background: #8e44ad; width: 300px; padding: 20px; border-radius: 10px; margin-bottom: 20px; }
        #tiempoBox { background: #e67e22; width: 300px; height: 120px; display:flex; flex-direction:column; justify-content:center; align-items:center; font-size:20px; font-weight:bold; border-radius: 10px; }

        /* WIDGET MODE (ESTILOS FINALES PARA EL OVERLAY) (INTACTO) */
        .widget-mode body { 
    background: transparent !important; /* Forzar fondo transparente */
    min-height: 100vh; /* CRÃTICO: Asegura que el cuerpo de la pÃ¡gina ocupa toda la ventana */
    display: block; 
    overflow: hidden; 
    margin: 0;
    padding: 0;
    width: 100vw; /* CRÃTICO: Asegura que el cuerpo de la pÃ¡gina ocupa todo el ancho */
}
        
        /* OCULTAR TODO LO QUE NO SEA EL WIDGET (INTACTO) */
        .widget-mode #main-dashboard-content { display: none !important; }
        .widget-mode #logDonaciones { display: none !important; } 

        /* ESTILOS DEL CONTENEDOR PRINCIPAL DEL WIDGET (INTACTO) */
        #widget-container {
    display: none; /* Por defecto oculto */
    flex-direction: column;
    width: 100%; /* CAMBIO: Ahora ocupa el 100% del cuerpo del widget */
    height: 100vh; /* CRÃTICO: Ocupa el 100% del alto de la ventana */
    margin: 0;
    /* ... (Otros estilos de borde y color intactos) ... */
}

        /* ESTILOS INTERNOS DEL WIDGET (INTACTO) */
        #tiempoBox-widget { background: #1a1a1a; width: 100%; padding: 10px 0; box-sizing: border-box; display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 8px 8px 0 0;border-bottom: 2px solid #FFD700; }
        #tiempoRestante-widget { font-size: 2.5em; color: #FFD700; font-weight: bold; text-shadow: 0 0 8px rgba(255, 215, 0, 0.7); }
        #subtext-widget { font-size: 14px; color: #ccc; margin-top: 5px; }
        .snipe-alert #tiempoRestante-widget { color: #FF4D4D !important; /* ROJO */ text-shadow: 0 0 15px rgba(255, 77, 77, 1) !important; /* Sombra ROJA mÃ¡s fuerte */}
        .snipe-alert #subtext-widget { color: #FF4D4D !important; /* ROJO */}


        #participantes-widget { 
    background: #1c2b3e; 
    width: 100%; 
    /* CRÃTICO: Usamos Flexbox para que esta lista ocupe todo el espacio que sobra */
    flex-grow: 1; 
    overflow-y: auto; /* Permite desplazamiento si la lista es muy larga */
    padding: 10px; 
    border-radius: 0 0 8px 8px;
    box-sizing: border-box; 
}
        #participantes-widget h2, #participantes-widget .totales { display: none; }
        #listaParticipantes-widget { padding: 0; margin: 0; list-style: none; }
        #listaParticipantes-widget li { display: flex; align-items: center; justify-content: space-between; background: #2a3d5e; margin-bottom: 8px; padding: 10px 15px; border-radius: 12px; font-size: 16px; font-weight: bold; border: 2px solid #555; box-shadow: 0 4px 8px rgba(0,0,0,0.4); }
        #listaParticipantes-widget li .coins { color: #ffd700; font-size: 1.1em; margin-left: 10px; display: flex; align-items: center; }
        /* #listaParticipantes-widget li .coins::before { content: 'ğŸª™'; margin-right: 5px; font-size: 0.9em; } */

        /* --- INICIO: ESTILOS CORRECTOS PARA EL RANKING DEL WIDGET --- */
        .rank-icon { 
            font-size: 1.2em; 
            color: #FFD700; /* NÃºmero de ranking en color oro */
            margin-right: 10px; 
            min-width: 25px; 
            height: 25px;
            text-align: center; 
            background: #3a4d70; /* Fondo circular azul oscuro */
            border-radius: 50%; /* Esto lo hace un cÃ­rculo */
            padding: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #FFD700; /* Borde dorado */
            box-sizing: border-box; /* Para que el padding no rompa el tamaÃ±o */
        }
        .user-info { 
            display: flex; 
            align-items: center; 
            flex-grow: 1; 
            overflow: hidden; 
        }
        .user-avatar { 
            width: 30px; 
            height: 30px; 
            border-radius: 50%; 
            overflow: hidden; 
            margin-right: 10px; 
            border: 2px solid #fff; 
        }
        .user-avatar img { 
            width: 100%; 
            height: 100%; 
            object-fit: cover; 
        }
        .username { 
    color: #ecf0f1; 
    
    /* ğŸ›‘ CAMBIOS APLICADOS: Permitir que el texto fluya libremente */
    white-space: normal; /* Permitir saltos de lÃ­nea si es necesario */
    overflow: visible; 
    text-overflow: clip; /* Deshabilita los '...' */
    max-width: none; /* Permite que el ancho sea el que necesite el nombre */
}
        /* --- FIN: ESTILOS CORRECTOS --- */
        #winner-popup {
            display: none; /* Oculto por defecto */
            position: fixed; /* Overlay que cubre todo */
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85); /* Fondo oscuro semitransparente */
            z-index: 100;
            /* Usamos flex para centrar el contenido */
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
            /* Para la animaciÃ³n de entrada/salida */
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #winner-content {
            background: linear-gradient(145deg, #1f2a3a, #1a2330);
            border: 4px solid #FFD700; /* Borde Dorado */
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            color: white;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.7); /* Brillo Dorado */
            /* AnimaciÃ³n "pop" de entrada */
            transform: scale(0.7);
            transition: transform 0.5s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }

        #winner-content h2 {
            margin: 0;
            font-size: 24px;
            color: #eee;
        }

        #winner-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 4px solid #FFD700;
            margin: 20px auto;
            overflow: hidden;
        }
        #winner-avatar img { width: 100%; height: 100%; object-fit: cover; }

        #winner-name {
            font-size: 48px;
            color: #FFD700;
            margin: 10px 0;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        #winner-content p {
            font-size: 20px;
            color: #ccc;
            margin: 10px 0;
        }
        #winner-content p span {
            color: #fff;
            font-weight: bold;
        }

        .felicidades {
            font-size: 28px !important;
            font-weight: bold;
            color: #FFD700 !important;
        }
        #titulo-principal-contenedor {
    width: 100%; /* Asegura que ocupe todo el ancho */
    text-align: center; /* Centra el texto */
    margin-bottom: 20px; /* Espacio debajo del tÃ­tulo */
}
#main-dashboard-content h1 { 
    width: 100%;        /* CRÃTICO: Hace que el tÃ­tulo ocupe toda la fila disponible */
    text-align: center; /* Centra el texto horizontalmente dentro del h1 */
    margin: 20px 0;     /* Mantiene el espaciado vertical que ya tenÃ­as */
}
.widget-mode #widget-container {
    display: flex !important; 
    position: static; 
    top: auto;
    left: auto;
    width: 100%; /* Â¡CRÃTICO! */
    height: 100%; /* Â¡CRÃTICO! */
    margin: 0;
}
    </style>
</head>
<body>
    
   <div id="main-dashboard-content" style="display: flex; flex-wrap: wrap; justify-content: center; width: 100%; max-width: 1200px;">
Â  Â  <h1>âš¡ Subasta en Vivo âš¡</h1>
Â  Â  
Â  Â  <div id="controles-group">
Â  Â  Â  Â  <div id="controles">
Â  Â  Â  Â  Â  Â  <h2>ğŸ® Controles</h2>
Â  Â  Â  Â  Â  Â  <label for="idUnico">ğŸ”‘ ID Ãšnico (para Widget):</label><br>
Â  Â  Â  Â  Â  Â  <input type="text" id="idUnico" placeholder="Ej: MiNombreDeUsuario" style="width: 90%; margin-bottom: 15px; padding: 5px;"><br>
Â  Â  Â  Â  Â  Â  <label>Usuario de TikTok:</label>
<input id="tiktokUser" placeholder="Ej: felipe_rivas" />
Â  Â  Â  Â  Â  Â  <div class="subcuadro">
Â  Â  Â  Â  Â  Â  Â  Â  <label for="tiempo">â± Tiempo inicial (segundos):</label><br>
Â  Â  Â  Â  Â  Â  Â  Â  <input type="number" id="tiempo" value="200"><br><br>
Â  Â  Â  Â  Â  Â  Â  Â  <label for="tiempoSnipe">Tiempo de snipe (segundos):</label>
Â  Â  Â  Â  Â  Â  Â  Â  <input type="number" id="tiempoSnipe" value="15" min="0">
Â  Â  Â  Â  Â  Â  Â  Â  <button class="start" onclick="iniciar()">Iniciar</button>
Â  Â  Â  Â  Â  Â  Â  Â  <button onclick="pausar()">Pausar</button>
Â  Â  Â  Â  Â  Â  Â  Â  <button class="stop" onclick="finalizar()">Finalizar</button> <button onclick="restart()">Restart</button>
Â  Â  Â  Â  Â  Â  Â  Â  <button style="background:#2ecc71; color:white;" onclick="abrirWidget()">Ver Widget</button>
Â  Â  Â  Â  Â  Â  Â  Â  <button onclick="simularRegalo()" style="background-color: #007bff; color: white; margin-top: 5px;">Simular Regalo</button>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div id="tiempoBox"><h2>â³ Tiempo Restante</h2><div id="tiempoRestante" style="font-size: 2.5em;">0</div></div>
Â  Â  </div>

Â  Â  <div id="logDonaciones" style="background: #333; color: #ccc; width: 350px; height: 400px; overflow-y: auto; margin: 20px; padding: 10px; border-radius: 10px; text-align: left; font-family: monospace; display: inline-block; vertical-align: top;">
Â  Â  Â  Â  <strong>ğŸ“ Historial de Eventos:</strong>
Â  Â  </div>

<div id="participantes" style="background: #27ae60; width: 350px; height: 400px; margin: 20px; display: flex; flex-direction: column;">
    <h2 style="padding: 10px 0; border-bottom: 1px solid rgba(0,0,0,0.1);">ğŸ‘¥ Participantes (Ronda Actual)</h2>
    
    <div id="lista-scroll" style="flex-grow: 1; overflow-y: auto;">
        <ul id="listaParticipantes" style="padding: 0; margin: 0;"></ul>
    </div>
    
    <div class="totales" style="padding: 10px; background: rgba(0,0,0,0.1); border-top: 1px solid rgba(0,0,0,0.1);">
        <p style="margin: 0; font-weight: bold;">Total participantes: <span id="totalParticipantes">0</span></p>
        <p style="margin: 5px 0 0 0; font-weight: bold;">Diamantes donados: <span id="totalDiamantes">0</span></p>
    </div>
</div>

Â  Â  <div id="ganadores" style="background: #2c3e50; width: 350px; height: 400px; overflow-y: auto; margin: 20px;">
Â  Â  Â  Â  <h2>ğŸ† Ganadores de Rondas</h2>
Â  Â  Â  Â  <ul id="listaGanadores"></ul>
Â  Â  </div> 
Â  Â  
Â  Â  </div> 
    Â  Â  <div id="widget-container">
Â  Â  <div id="tiempoBox-widget">
Â  Â  Â  Â  <div id="tiempoRestante-widget">--:--</div>
Â  Â  Â  Â  <div id="subtext-widget">El sorteo/subasta termina en</div>
Â  Â  </div>

Â  Â  <div id="participantes-widget">
Â  Â  Â  Â  <ul id="listaParticipantes-widget"></ul>
Â  Â  </div>
</div>
Â  Â  Â  Â  
Â  Â  <div id="winner-popup" style="display: none;">
Â  Â  Â  Â  <div id="winner-content">
Â  Â  Â  Â  Â  Â  <h2>Â¡Ganador de la Ronda!</h2>
Â  Â  Â  Â  Â  Â  <div id="winner-avatar"><img></div>
Â  Â  Â  Â  Â  Â  <h1 id="winner-name">@username</h1>
Â  Â  Â  Â  Â  Â  <p>DonÃ³ un total de <span id="winner-amount">0</span> ğŸ’</p>
Â  Â  Â  Â  Â  Â  <p class="felicidades">Â¡Felicidades! ğŸ†</p>
Â  Â  Â  Â  </div>
Â  Â  </div>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    
    <script>
        const socket = io("https://tiktok-servidor2.onrender.com"); // tu URL real de Render

        const listaParticipantesEl = document.getElementById('listaParticipantes');
        const listaGanadoresEl = document.getElementById('listaGanadores');
        const tiempoRestanteEl = document.getElementById('tiempoRestante');
        const logDonacionesEl = document.getElementById('logDonaciones');
        
        let tiempoActual = 0;
        let intervalo = null;
        let participantes = {};
        let ganadoresHistorial = [];
        let isPaused = false; // Estado para la funciÃ³n pausar
        let snipeActivado = false; // <-- AÃ‘ADE ESTA LÃNEA
        let subastaActiva = false;
        let isSnipeModeVisual = false;
        let isConnectedValid = false;
// ğŸ›‘ SOLUCIÃ“N DE INYECCIÃ“N SEGURA PARA CORREGIR LA DECLARACIÃ“N
if (Array.isArray(participantes)) {
    participantes = {}; // Forzamos a que sea un objeto vacÃ­o
}
        // ğŸ‘‡ INICIO: AÃ‘ADIDO BLOQUE (PROTECCIÃ“N ANTI-DUPLICADOS) ğŸ‘‡
        const processedGiftIds = new Set();
        setInterval(() => {
          processedGiftIds.clear();
          console.log("Limpiando cachÃ© de IDs de regalos procesados.");
        }, 60000); // Limpia los IDs cada 60 segundos
        // ğŸ‘† FIN: AÃ‘ADIDO BLOQUE ğŸ‘†

        // --- FUNCIONES DE UTILIDAD ---
        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }
        
        function actualizarParticipantesUI() {
    // ğŸ›‘ PASO 1: CONVERTIR EL OBJETO PARTICIPANTES A UN ARRAY TEMPORAL
    const participantesArray = Object.values(participantes);
    
    // PASO 2: Ordenar el nuevo array (participantesArray)
    participantesArray.sort((a, b) => parseInt(b.cantidad) - parseInt(a.cantidad));

    // ğŸ›‘ PASO 3 CRÃTICO: CALCULAR TOTALES
    let totalDiamantes = 0;
    participantesArray.forEach(p => {
        totalDiamantes += parseInt(p.cantidad) || 0; // Suma de todos los diamantes
    });

    // -----------------------------------------------------------
    // LÃ³gica de dibujo de lista (Ya estaba correcta)
    // -----------------------------------------------------------
    const listaDashboard = document.getElementById("listaParticipantes");
    const listaWidget = document.getElementById("listaParticipantes-widget");
    if (listaDashboard) listaDashboard.innerHTML = "";
    if (listaWidget) listaWidget.innerHTML = "";

    // PASO 4: Recorrer el array ordenado y dibujar (MANTENER TU CÃ“DIGO)
    // ... (Tu cÃ³digo para recorrer participantesArray y dibujar li's) ...
    participantesArray.forEach((p, index) => { 
        // ... (Tu cÃ³digo de itemHTML aquÃ­) ...
        const itemHTML = `
            <li class="participante-item">
                <div style="display:flex; align-items:center; gap:10px;">
                    <span class="rank">${index + 1}.</span>
                    <img src="${p.avatar_url || 'https://via.placeholder.com/40/000/fff?text=U'}"
                        alt="${p.usuario || 'Usuario'}" 
                        style="width:40px; height:40px; border-radius:50%;"> 
                    
                    <span class="username" title="${p.usuario}"> ${p.usuario}
                    </span>
                </div>
                <div class="coins">${p.cantidad} ğŸ’</div>
            </li>
        `;
        // ... (Tu lÃ³gica para aÃ±adir a listaDashboard y listaWidget) ...
        if (listaDashboard && !document.body.classList.contains('widget-mode')) {
            listaDashboard.innerHTML += itemHTML;
        }
        if (listaWidget && document.body.classList.contains('widget-mode')) {
            // Solo dibujamos el top 5 para el widget, pero para esta prueba, mantenemos todos.
            listaWidget.innerHTML += itemHTML;
        }
    });

    // ğŸ›‘ PASO 5 CRÃTICO: ACTUALIZAR LOS TOTALES DE LA TABLA
    const isWidgetMode = document.body.classList.contains('widget-mode');
    
    if (!isWidgetMode) {
        // Usamos el selector robusto. Si falla, el problema es el HTML.
        const totalParticipantesEl = document.querySelector('span#totalParticipantes');
        const totalDiamantesEl = document.querySelector('span#totalDiamantes');
        
        if (totalParticipantesEl) {
            // USAMOS LA LONGITUD DEL ARRAY CALCULADO EN ESTA FUNCIÃ“N
            totalParticipantesEl.textContent = participantesArray.length; 
        }
        if (totalDiamantesEl) {
            // USAMOS EL TOTAL CALCULADO EN ESTA FUNCIÃ“N
            totalDiamantesEl.textContent = totalDiamantes; 
        }
    }
}
        function obtenerGanador() {
    if (participantes.length === 0) return null;
    return participantes.reduce((max, p) => (p.coins > max.coins ? p : max));
}


        function actualizarGanadoresUI() {
            const listaGanadoresEl = document.getElementById('listaGanadores');
            listaGanadoresEl.innerHTML = "";
            ganadoresHistorial.forEach(g => {
                const li = document.createElement('li');
                li.textContent = `ğŸ† ${g.usuario} - ${g.cantidad} ğŸ’`;
                listaGanadoresEl.appendChild(li);
            });
        }
        
        // --- LÃ“GICA DEL TEMPORIZADOR ---
            function iniciarTimerLogic() {
    let tiempoInput = document.getElementById("tiempo");
    
    // 1. InicializaciÃ³n
    if (tiempoActual <= 0) {
        tiempoActual = parseInt(tiempoInput ? tiempoInput.value : 200); 
    }

    // 2. Limpia cualquier intervalo anterior
    if (intervalo) clearInterval(intervalo);
    
    intervalo = setInterval(() => {
        
        // A) LÃ³gica de Cuenta Regresiva (Solo si NO estÃ¡ pausado y el tiempo es > 0)
        if (!isPaused && tiempoActual > 0) {
            tiempoActual--;
            const formattedTime = formatTime(tiempoActual);
            
            // SincronizaciÃ³n y ActualizaciÃ³n UI
            if (!document.body.classList.contains('widget-mode')) {
                socket.emit('sync_time', tiempoActual); 
            }
            if (document.getElementById('tiempoRestante')) document.getElementById('tiempoRestante').textContent = formattedTime;
        } 
        
        // ğŸ›‘ B) LÃ“GICA DE TERMINACIÃ“N (TIEMPO = 0) ğŸ›‘
        // CRÃTICO: Este IF debe ser INDEPENDIENTE de la cuenta regresiva (A)
        if (tiempoActual <= 0 && !document.body.classList.contains('widget-mode')) {
            
            // Detener el loop y liberar la variable
            clearInterval(intervalo);
            intervalo = null;
            
            // Llamar a la lÃ³gica de Snipe/finalizaciÃ³n
            terminarTiempo(); 
        }

    }, 1000);
}

        // --- FUNCIONES DE CONTROL ---
       function iniciar() {
    if (!document.body.classList.contains('widget-mode')) { 
        
        // ğŸ›‘ VALIDACIÃ“N 1: Verificar si el ID estÃ¡ en el input
        const idUnicoEl = document.getElementById('idUnico');
        const streamerIdActual = idUnicoEl ? idUnicoEl.value.trim() : "";
        
        if (!streamerIdActual) {
            alert("âš ï¸ ERROR: Debes escribir el ID Ãšnico (para Widget) antes de iniciar la subasta.");
            logDonacionesEl.innerHTML += `<p style="color: red;">ğŸ›‘ ERROR: ID Ãšnico no especificado. No se puede iniciar la subasta.</p>`;
            return; // Detiene la funciÃ³n aquÃ­
        }
        
        // ğŸ›‘ LÃ³gica de ConexiÃ³n: Asumimos que conectarDashboard() se encarga de isConnectedValid
        conectarDashboard(); 

        // ğŸ›‘ VALIDACIÃ“N 2: CRÃTICA. SOLO INICIAR SI EL ID ES VÃLIDO EN EL SERVIDOR
        if (!isConnectedValid) {
            alert("âš ï¸ ERROR: El ID no ha sido validado por el servidor. Revisa si hay un mensaje de error.");
            return; // Detiene la funciÃ³n si el servidor ya marcÃ³ el ID como invÃ¡lido
        }
        
        // --- LÃ³gica de REINICIO Y LIMPIEZA CRÃTICA ---
        
        // ğŸ›‘ LIMPIEZA 1: Resetear la bandera del Snipe
        snipeActivado = false; // ESTO SOLUCIONA QUE LA SEGUNDA RONDA NO INICIE EN SNIPE
        
        // ğŸ›‘ LIMPIEZA 2: Limpiar lista local de participantes y la UI
        participantes = {}; // Limpia la variable global local
        actualizarParticipantesUI(); // Actualiza el dashboard (muestra Total: 0, etc.)
        
        // ğŸ›‘ LIMPIEZA 3: Ocultar el modal del ganador de la ronda anterior (si es que existe)
        if (typeof ocultarGanadorUI === 'function') {
            ocultarGanadorUI(); 
        } else {
            // Alternativa si no tienes esa funciÃ³n, usa el ID del modal:
            const modalGanador = document.getElementById('modalGanador'); // Asumiendo este ID
            if (modalGanador) modalGanador.style.display = 'none';
        }
        // ğŸ›‘ LIMPIEZA 4: CRÃTICA VISUAL (AÃ‘ADE ESTA LÃNEA) ğŸ›‘
// Esto envÃ­a la orden al Widget de quitar el color rojo y el texto de alerta.
socket.emit("desactivar_alerta_snipe_visual");

        // --- LÃ³gica de inicio (SOLO se ejecuta si isConnectedValid es true) ---
        subastaActiva = true; 
        logDonacionesEl.innerHTML += `<p style="color: yellow;">â–¶ï¸ Iniciando ronda...</p>`;
        
        // Si el servidor valida el ID y llegamos aquÃ­, entonces enviamos el evento
        socket.emit("iniciar_subasta"); 
        
        isPaused = false; 
        tiempoActual = 0; // Se fuerza a 0 para que iniciarTimerLogic tome el valor del input
        iniciarTimerLogic(); // Inicia el reloj maestro en el dashboard
    }
}
function conectarDashboard() {
    // 1. Lee el ID Ãºnico del streamer (para el widget)
    const idUnicoEl = document.getElementById('idUnico');
    const streamerIdActual = idUnicoEl ? idUnicoEl.value.trim() : "";

    // 2. Lee el username de TikTok desde un input adicional
    const tiktokUserEl = document.getElementById('tiktokUser');
    const tiktokUserActual = tiktokUserEl ? tiktokUserEl.value.trim() : "";

    // 3. Validaciones
    if (!streamerIdActual) {
        alert("âŒ Debes escribir el ID Ãšnico (para Widget) antes de iniciar la subasta.");
        isConnectedValid = false;
        return;
    }

    if (!tiktokUserActual) {
        alert("âš ï¸ Debes escribir tu nombre de usuario de TikTok (sin @).");
        isConnectedValid = false;
        return;
    }

    // 4. Marcar la conexiÃ³n como vÃ¡lida (hasta que el servidor diga lo contrario)
    isConnectedValid = true;

    // 5. Emitir el evento de uniÃ³n a la sala
    socket.emit("join_room", { 
        streamerId: streamerIdActual, 
        tiktokUser: tiktokUserActual 
    });

    // 6. Guardar variables globales
    streamerId = streamerIdActual;
    tiktokUser = tiktokUserActual;

    console.log(`âœ… DASHBOARD conectado a sala: ${streamerIdActual} (usuario TikTok: ${tiktokUserActual})`);
}

        function terminarTiempo() {
    // 1. Esta funciÃ³n solo debe correr en el Dashboard (el "Maestro")
    if (!document.body.classList.contains('widget-mode')) { 
        socket.emit("restaurar_widget");

        // 2. Detiene el reloj
        if (intervalo) { 
            clearInterval(intervalo); 
            intervalo = null; 
        }

        // 3. Avisa a todos que el tiempo (y la subasta) se acabÃ³
        socket.emit('finalizar_subasta'); // Avisa al servidor que no acepte mÃ¡s regalos
        socket.emit('sync_time', 0); // EnvÃ­a '0' a los widgets
        tiempoActual = 0; 
        if (document.getElementById('tiempoRestante')) {
            document.getElementById('tiempoRestante').textContent = formatTime(0);
        }

        // 4. Revisa si hay que activar el SNIPE
        // (Nota: cambiÃ© el default de 15 a 0 para mÃ¡s seguridad)
        const tiempoSnipe = parseInt(document.getElementById("tiempoSnipe").value) || 0;

        if (!snipeActivado && tiempoSnipe > 0) {
            // A) AÃšN QUEDA EL SNIPE
            snipeActivado = true; // Marcamos que el snipe ya se usÃ³
            logDonacionesEl.innerHTML += `<p style="color: yellow;">âš¡ Modo SNIPE activado (${tiempoSnipe}s extra)</p>`;

            // Avisamos a los widgets del nuevo tiempo
            socket.emit("iniciar_snipe_cliente", tiempoSnipe);

            // ğŸ›‘ NUEVA EMISIÃ“N: Avisamos a los Widgets que inicien la ALERTA ROJA ğŸ›‘
            socket.emit("activar_alerta_snipe_visual"); // <--- AÃ‘ADE ESTA LÃNEA

            // Reiniciamos el temporizador local solo con el tiempo de snipe
            tiempoActual = tiempoSnipe;
            iniciarTimerLogic();

        } 
        // ğŸ›‘ ELSE CRÃTICO: SOLO ENTRA AQUÃ SI EL SNIPE YA TERMINÃ“ O NO EXISTÃA ğŸ›‘
        else {
            // B) LÃ“GICA DE FINALIZACIÃ“N Y GANADOR
            
            if (snipeActivado) {
                logDonacionesEl.innerHTML += `<p style="color: red;">â¹ï¸ Ronda finalizada automÃ¡ticamente (post-snipe).</p>`;
            } else {
                logDonacionesEl.innerHTML += `<p style="color: red;">â¹ï¸ Ronda finalizada automÃ¡ticamente (sin snipe).</p>`;
            }

            // --- LÃ“GICA DE ANUNCIAR GANADOR ---
            const participantesArray = Object.values(participantes); 
            
            if (participantesArray.length > 0) {
                participantesArray.sort((a, b) => parseInt(b.cantidad) - parseInt(a.cantidad)); 
                
                const ganador = participantesArray[0];
                ganadoresHistorial.unshift(ganador);
                logDonacionesEl.innerHTML += `<p style="color: gold;">ğŸ† Â¡Ganador guardado: ${ganador.usuario} con ${ganador.cantidad} diamantes!</p>`;
                actualizarGanadoresUI();
                socket.emit("anunciar_ganador", ganador);
            } else {
                logDonacionesEl.innerHTML += `<p style="color: gray;">â„¹ï¸ No hubo participantes en esta ronda.</p>`;
            }
            
            // ğŸ›‘ ÃšLTIMO PASO CRÃTICO DE LIMPIEZA
            // NO importa si hubo ganador o no, el SNIPE DEBE REINICIARSE.
            snipeActivado = false; 
            subastaActiva = false; // Es buena prÃ¡ctica reiniciarla aquÃ­ tambiÃ©n.
        }
    }
}
        function finalizar() {
    // 1. Esta funciÃ³n solo debe correr en el Dashboard (el "Maestro")
    if (!document.body.classList.contains('widget-mode')) {

        // 2. Detener CUALQUIER temporizador que estÃ© activo
        if (intervalo) { 
            clearInterval(intervalo); 
            intervalo = null; 
        }
        
        // 3. Sincronizar el tiempo a 0 en todos lados
        tiempoActual = 0;
        socket.emit('sync_time', 0); // EnvÃ­a '0' a los widgets
        if (document.getElementById('tiempoRestante')) {
            document.getElementById('tiempoRestante').textContent = formatTime(0);
        }
        
        // 4. Avisar al servidor que la subasta se detenga INMEDIATAMENTE
        socket.emit('finalizar_subasta'); 

        // 5. Loggear que fue manual
        logDonacionesEl.innerHTML += `<p style="color: red;">â¹ï¸ Ronda finalizada manualmente.</p>`;

        // 6. Procesar al ganador (si existe)
        const participantesArray = Object.values(participantes); // ğŸ›‘ CRÃTICO: Convertir a array

Â  Â  Â  Â  if (participantesArray.length > 0) { // ğŸ›‘ Usamos la longitud del array

Â  Â  Â  Â  Â  Â  participantesArray.sort((a, b) => parseInt(b.cantidad) - parseInt(a.cantidad)); // Ordena de mayor a menor

Â  Â  Â  Â  Â  Â  const ganador = participantesArray[0]; // Ahora sÃ­, el [0] es el que mÃ¡s donÃ³
Â  Â  Â  Â  Â  Â  ganadoresHistorial.unshift(ganador); 
Â  Â  Â  Â  Â  Â  logDonacionesEl.innerHTML += `<p style="color: gold;">ğŸ† Â¡Ganador guardado: ${ganador.usuario} con ${ganador.cantidad} diamantes!</p>`;
Â  Â  Â  Â  Â  Â  actualizarGanadoresUI();
Â  Â  Â  Â  Â  Â  socket.emit("anunciar_ganador", ganador); // EnvÃ­a al ganador correcto
Â  Â  Â  Â  
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â logDonacionesEl.innerHTML += `<p style="color: gray;">â„¹ï¸ No hubo participantes en esta ronda.</p>`;
Â  Â  Â  Â  }

        // 7. APAGAR EL INTERRUPTOR Y LIMPIAR (SIEMPRE)
        subastaActiva = false; // <--- LUGAR CORRECTO (Fuera del if/else del ganador)
        participantes = {}; 
        actualizarParticipantesUI(); 
        socket.emit("limpiar_listas"); // (Esta es la Ãºnica llamada que debe estar)
    }
}
          
        function restart() {
    if (!document.body.classList.contains('widget-mode')) { // Solo el dashboard puede reiniciar
        finalizar(); // Finaliza la ronda actual (guarda ganador si hay, limpia lista)
        // Limpia el historial de ganadores tambiÃ©n
        ganadoresHistorial = [];
        actualizarGanadoresUI();
        
        // ğŸ” Resetea variables globales
        snipeActivado = false; // <-- Muy importante para permitir un nuevo snipe en la siguiente subasta
        
        logDonacionesEl.innerHTML = '<strong>ğŸ“ Historial de Eventos:</strong><p style="color: cyan;">ğŸ”„ Sistema reiniciado. Listo para una nueva subasta.</p>';
        
        // No emitimos iniciar_subasta aquÃ­, esperamos que el usuario presione Iniciar
        // Pero sÃ­ reseteamos el tiempo visual a 0
        if (document.getElementById('tiempoRestante')) 
            document.getElementById('tiempoRestante').textContent = formatTime(0);
        
        socket.emit('sync_time', 0); // Asegurar que widgets muestren 0
    }
}


        function pausar() {
            if (!document.body.classList.contains('widget-mode')) { // Solo el dashboard puede pausar
                isPaused = !isPaused; // Invierte el estado (true/false)
                if (isPaused) {
                    if (intervalo) clearInterval(intervalo); // Detenemos el intervalo local
                    intervalo = null; // Marcar como detenido
                    logDonacionesEl.innerHTML += `<p style="color: orange;">â¸ï¸ Temporizador en pausa.</p>`;
                    // No enviamos nada al servidor, el widget se queda con la Ãºltima hora recibida
                } else {
                    iniciarTimerLogic(); // Reanudamos la lÃ³gica (continÃºa desde tiempoActual)
                    logDonacionesEl.innerHTML += `<p style="color: green;">â–¶ï¸ Temporizador reanudado.</p>`;
                }
            }
        }
        // ğŸ‘‡ AÃ‘ADE ESTA FUNCIÃ“N COMPLETA ğŸ‘‡
        function simularRegalo() {
            // Solo el dashboard (maestro) puede simular
            if (document.body.classList.contains('widget-mode')) return;

            // 1. Nombres y montos aleatorios
            const nombres = ["GatitoVeloz", "LoboEstelar", "ZorroGamer", "PandaNinja", "DragonRojo"];
            const randomUser = nombres[Math.floor(Math.random() * nombres.length)] + Math.floor(Math.random() * 500);
            const randomAmount = Math.floor(Math.random() * 100) + 1; // Simular donaciÃ³n de 1 a 100
            const giftName = "SimulaciÃ³n";

            // 2. Obtener el total anterior (si el usuario ya existe)
            const existente = participantes.find(p => p.usuario === randomUser);
            let nuevoTotal;

            if (existente) {
                nuevoTotal = existente.cantidad + randomAmount; // Sumamos la nueva donaciÃ³n al total
            } else {
                nuevoTotal = randomAmount; // Es un usuario nuevo
            }
            
            // 3. Mostrar en el log del dashboard
            logDonacionesEl.innerHTML += `<p style="color: gray;">[SIM] ${randomUser} enviÃ³ +${randomAmount}ğŸª™ (Nuevo Total: ${nuevoTotal})</p>`;
            logDonacionesEl.scrollTop = logDonacionesEl.scrollHeight;

            // 4. Emitir al servidor el *NUEVO TOTAL*
            // (El servidor lo retransmitirÃ¡, y socket.on("new_gift") lo reemplazarÃ¡)
            socket.emit("nuevo_regalo", {
  usuario: randomUser,
  cantidad: nuevoTotal,
  regalo: giftName,
  avatar_url: profilePictureUrl || "https://via.placeholder.com/40/555/FFFFFF?text=U"
});
        }
        // ğŸ‘† FIN DE LA FUNCIÃ“N NUEVA ğŸ‘†

        // --- EVENTOS DE SINCRONIZACIÃ“N (El Widget recibe la hora) ---
        socket.on('update_time', (time) => {
    
    if (document.body.classList.contains('widget-mode')) {
        
        // ... (Tu lÃ³gica existente para subastaActiva) ...

        tiempoActual = time;
        const formattedTime = formatTime(time);
        
        const tiempoElWidget = document.getElementById('tiempoRestante-widget'); 
        const subtextElWidget = document.getElementById('subtext-widget');
        
        if (tiempoElWidget) tiempoElWidget.textContent = formattedTime;
        
        // ğŸ›‘ LÃ“GICA DE CAMBIO DE CLASE AHORA USA LA BANDERA ğŸ›‘
        
        // Si la bandera estÃ¡ ACTIVA (solo se activa cuando el tiempo llega a cero por primera vez)
        if (isSnipeModeVisual && time > 0) {
            
            // 1. Activa la clase 'snipe-alert'. Â¡El contador se pone ROJO!
            document.body.classList.add('snipe-alert');
            
            // 2. Cambia el texto del subtÃ­tulo a la alerta
            if (subtextElWidget) {
                subtextElWidget.textContent = "Tiempo por delay de live"; 
            }
        
            } else {
                
                // 1. Desactiva la clase (vuelve al AMARILLO original si no estÃ¡ en Snipe)
                document.body.classList.remove('snipe-alert');
                
                // 2. Restaura el texto original del subtÃ­tulo (si la subasta aÃºn no ha terminado, es el texto por defecto)
                if (subtextElWidget) {
                    subtextElWidget.textContent = "El sorteo/subasta termina en"; 
                }
            }
        }
    });

    // --- DETECCIÃ“N DE WIDGET O DASHBOARD ---
const urlParams = new URLSearchParams(window.location.search);

// Detecta si la URL es /widget O si tiene ?mode=widget
const currentPath = window.location.pathname || "";
const isWidgetMode = window.location.search.includes("mode=widget") || currentPath.includes("/widget");

// Variables globales (se llenarÃ¡n dependiendo del modo)
let streamerId = "";
let tiktokUser = "";

if (isWidgetMode) {
    // ===============================
    // ğŸƒ MODO WIDGET
    // ===============================
    console.log("ğŸŸ£ Modo Widget activado.");

    // 1. APLICA LA CLASE (Tu CSS se encargarÃ¡ de los estilos)
    document.body.classList.add("widget-mode");

    // 2. OCULTA EL DASHBOARD (Tu CSS ya lo hace, pero forzamos)
    const mainDashboardContent = document.getElementById("main-dashboard-content");
    if (mainDashboardContent) mainDashboardContent.style.display = "none";

    // 3. MUESTRA EL CONTENEDOR DEL WIDGET (El que SÃ existe en tu HTML)
    const widgetContainer = document.getElementById("widget-container");
    if (widgetContainer) {
        widgetContainer.style.display = 'flex'; // O 'block', segÃºn tu diseÃ±o
    } else {
        console.error("CRÃTICO: No se encontrÃ³ #widget-container en el HTML.");
    }

    // 4. LEE EL ID DE LA URL Y CONECTA
    streamerId = urlParams.get("streamerId"); // AsegÃºrate que tu Step 2 envÃ­a 'streamerId'
    if (streamerId) {
        socket.emit("join_room", { streamerId, tiktokUser: "WidgetCliente" });
        console.log(`âœ… WIDGET unido a la sala de ${streamerId}`);
    } else {
        console.error("âš ï¸ El Widget no recibiÃ³ el streamerId en la URL");
    }

} else {
    // ===============================
    // ğŸ–¥ï¸ MODO DASHBOARD
    // ===============================
    console.log("ğŸ›ï¸ Dashboard normal");

    // Oculta el contenedor del widget (por si acaso)
    const widgetContainer = document.getElementById("widget-container");
    if (widgetContainer) widgetContainer.style.display = "none";

    // 5. LÃ“GICA DEL DASHBOARD (Lee los inputs)
    const idUnicoEl = document.getElementById('idUnico');
    const tiktokUserEl = document.getElementById('tiktokUser');
    
    // (Tu lÃ³gica para leer los inputs y conectar a TikTok va aquÃ­)
    // ...
}
    // ===============================
    // ğŸ ESCUCHAR REGALOS EN TIEMPO REAL DESDE EL SERVIDOR
    // (Esto corre en AMBOS: Dashboard y Widget)
// ===============================
socket.on("new_gift", (giftData) => {
    // âœ… LÃ“GICA DE CLIENTE SIMPLIFICADA (SOLO LOGS)
    const nickname = giftData.nickname || giftData.username || "Desconocido";
    const giftName = giftData.giftName || giftData.gift_name || "Regalo";
    const diamantes = giftData.diamondCount || giftData.diamond_count || giftData.diamonds || giftData.amount || 0;
    
    logDonacionesEl.innerHTML += `<p style="color: cyan;">ğŸ ${nickname} enviÃ³ ${giftName} (${diamantes} ğŸ’)</p>`;
    logDonacionesEl.scrollTop = logDonacionesEl.scrollHeight;

    // La actualizaciÃ³n de la UI se manejarÃ¡ en 'update_participantes'
});
// ğŸ“¢ Â¡AQUÃ VA LA LÃNEA DE SINCRONIZACIÃ“N!
            // Ahora la variable 'participantes' estÃ¡ finalizada, sumada y ordenada.
Â  Â  Â  Â  Â  Â  socket.emit('sync_participantes', participantes); // <-- Â¡MOVER AQUÃ!

Â  Â  Â  Â  Â  Â  // Ahora sÃ­, actualiza la UI con la lista ya ordenada
Â  Â  Â  Â  Â  Â  actualizarParticipantesUI();
Â  Â  Â  Â  ;
socket.on('id_invalido', (data) => {
    // ğŸ›‘ 1. Establecer la bandera como invÃ¡lida
    isConnectedValid = false; 

    // ğŸ›‘ 2. Detener la lÃ³gica de la subasta/tiempo
    subastaActiva = false;
    clearInterval(intervalo);
    logDonacionesEl.innerHTML += `<p style="color: red;">ğŸ›‘ ERROR: ConexiÃ³n rechazada. ID InvÃ¡lido: ${data.streamerId}</p>`;
    
    // Muestra la alerta (como ya lo tienes)
    alert(`âŒ ERROR: El ID '${data.streamerId}' no estÃ¡ en la lista autorizada. Por favor, comunÃ­cate con el administrador.`);
});
// ğŸ›‘ FIN DEL BLOQUE A AÃ‘ADIR ğŸ›‘
// ===============================
// ğŸ§¹ Limpiar listas cuando el servidor lo indique
// ===============================
socket.on("limpiar_listas_clientes", () => {
    console.log("ğŸ§¹ Recibido comando para limpiar lista local.");
    participantes = {};
    actualizarParticipantesUI();
    subastaActiva = false;
    console.log("CLIENTE: Interruptor APAGADO.");
});

// ===============================
// ğŸ§­ FunciÃ³n para actualizar la UI (debe ir FUERA de socket.on)
// ===============================
    function actualizarParticipantesUI() {
    // ğŸ›‘ PASO 1: CONVERTIR EL OBJETO PARTICIPANTES A UN ARRAY TEMPORAL
    const participantesArray = Object.values(participantes);
    
    // PASO 2: Ordenar el nuevo array (participantesArray)
    participantesArray.sort((a, b) => parseInt(b.cantidad) - parseInt(a.cantidad));

    // ğŸ›‘ PASO 3: INICIALIZAR CONTADOR DE DIAMANTES
    let totalDiamantes = 0; 

    // 4. Limpiar listas
    const listaDashboard = document.getElementById("listaParticipantes");
    const listaWidget = document.getElementById("listaParticipantes-widget");
    if (listaDashboard) listaDashboard.innerHTML = "";
    if (listaWidget) listaWidget.innerHTML = "";

    // PASO 5: Recorrer el array ordenado y SUMAR DIAMANTES
    participantesArray.forEach((p, index) => { 
        // â¡ï¸ Â¡SUMA DE DIAMANTES AQUÃ!
        totalDiamantes += parseInt(p.cantidad) || 0; 
        
        const itemHTML = `
            <li class="participante-item">
                <div style="display:flex; align-items:center; gap:10px;">
                    <span class="rank">${index + 1}.</span>
                    <img src="${p.avatar_url || 'https://via.placeholder.com/40/000/fff?text=U'}"
                        alt="${p.usuario || 'Usuario'}" 
                        style="width:40px; height:40px; border-radius:50%;"> 
                    
                    <span class="username" title="${p.usuario}"> ${p.usuario}
                    </span>
                </div>
                <div class="coins">${p.cantidad} ğŸ’</div>
            </li>
        `;

        if (listaDashboard && !document.body.classList.contains('widget-mode')) {
            listaDashboard.innerHTML += itemHTML;
        }

        if (listaWidget && document.body.classList.contains('widget-mode')) {
            listaWidget.innerHTML += itemHTML;
        }
    });

    // ğŸ›‘ PASO 6: ACTUALIZAR LOS CONTADORES (solo en Dashboard)
    const isWidgetMode = document.body.classList.contains('widget-mode');
    
    if (!isWidgetMode) {
        // Buscamos los elementos por ID/Selector
        const totalParticipantesEl = document.querySelector('span#totalParticipantes');
        const totalDiamantesEl = document.querySelector('span#totalDiamantes');
        
        if (totalParticipantesEl) {
            // USAMOS LA LONGITUD DEL ARRAY
            totalParticipantesEl.textContent = participantesArray.length; 
        }
        if (totalDiamantesEl) {
            // USAMOS LA SUMA TOTAL
            totalDiamantesEl.textContent = totalDiamantes; 
        }
    }
}

function abrirWidget() {
    // 1. Lee el ID del input (id="idUnico")
    const streamerIdInput = document.getElementById('idUnico'); 
    const streamerId = streamerIdInput ? streamerIdInput.value.trim() : '';
    
    if (!streamerId) {
        alert('Por favor, introduce el ID del Streamer primero.');
        return;
    }
    
    // 2. ğŸ›‘ CRÃTICO: USA LA URL COMPLETA DE TU SERVIDOR DE RENDER
    // Reemplaza esto con tu URL real si es diferente
    const baseUrl = "https://tiktok-servidor2.onrender.com"; 
    
    const widgetURL = `${baseUrl}/widget?streamerId=${streamerId}`; 
    
    // 3. Abre la nueva ventana
    console.log("Abriendo Widget en:", widgetURL); // Revisa la consola del Dashboard
    window.open(widgetURL, 'WidgetSubasta', 'width=360,height=580'); 
}
/* ================================================== */
/* ğŸ‘‘ BLOQUE ÃšNICO PARA MOSTRAR GANADOR (Dashboard + Widget) ğŸ‘‘ */
/* ================================================== */
socket.on("anunciar_ganador", (ganador) => {
    if (!ganador || !ganador.usuario) {
        console.log("âš ï¸ No hubo ganador en esta ronda.");
        return;
    }

    const isWidget = document.body.classList.contains('widget-mode');

    if (!isWidget) {
        // ===========================
        // ğŸ–¥ï¸ MOSTRAR EN DASHBOARD
        // ===========================
        console.log("ğŸ¬ Mostrando popup de ganador en el Dashboard:", ganador.usuario);

        const popup = document.getElementById('winner-popup');
        const nameEl = document.getElementById('winner-name');
        const amountEl = document.getElementById('winner-amount');
        const avatarImgEl = document.getElementById('winner-avatar').querySelector('img');
        const contentEl = document.getElementById('winner-content');

        nameEl.textContent = ganador.usuario;
        amountEl.textContent = ganador.cantidad + " ğŸª™";
        avatarImgEl.src = ganador.avatar_url || 'https://via.placeholder.com/100/555/FFFFFF?text=A';

        requestAnimationFrame(() => {
            popup.style.display = 'flex';
            requestAnimationFrame(() => {
                popup.style.opacity = '1';
                contentEl.style.transform = 'scale(1)';
            });
        });

        setTimeout(() => {
            popup.style.opacity = '0';
            contentEl.style.transform = 'scale(0.7)';
            setTimeout(() => {
                popup.style.display = 'none';
                socket.emit("limpiar_listas");
            }, 500);
        }, 10000);

    } else {
Â  Â  Â  Â  // ===========================
Â  Â  Â  Â  // ğŸ“º MOSTRAR EN WIDGET (TIKTOK STUDIO)
Â  Â  Â  Â  // ===========================
Â  Â  Â  Â  console.log("ğŸ‘‘ Mostrando ganador en el widget:", ganador.usuario);

Â  Â  Â  Â  // 1ï¸âƒ£ Limpiar el ranking
Â  Â  Â  Â  const rankingList = document.getElementById("listaParticipantes-widget");
Â  Â  Â  Â  if (rankingList) rankingList.innerHTML = "";
Â  Â  Â  Â  participantes = {}; // âœ… Â¡AsegÃºrate de que sea un OBJETO vacÃ­o!

Â  Â  Â  Â  // 2ï¸âƒ£ Crear un banner flotante encima del widget
        // ... (el resto de tu lÃ³gica para crear el container SÃ deberÃ­a funcionar)

        // 2ï¸âƒ£ Crear un banner flotante encima del widget
        const container = document.createElement("div");
        container.id = "widget-winner-popup";
        container.style.position = "fixed";
        container.style.top = "10%";
        container.style.left = "50%";
        container.style.transform = "translateX(-50%)";
        container.style.zIndex = "9999";
        container.style.background = "rgba(0,0,0,0.85)";
        container.style.color = "#fff";
        container.style.padding = "25px 50px";
        container.style.borderRadius = "20px";
        container.style.textAlign = "center";
        container.style.fontSize = "1.6em";
        container.style.backdropFilter = "blur(6px)";
        container.style.boxShadow = "0 0 20px rgba(255, 215, 0, 0.8)";
        container.style.animation = "popIn 0.4s ease";

        container.innerHTML = `
            <div style="display:flex; align-items:center; justify-content:center; gap:15px;">
                <img src="${ganador.avatar_url || 'https://via.placeholder.com/60/000/fff?text=?'}"
                     style="width:60px; height:60px; border-radius:50%; border:3px solid gold;">
                <div>
                    <div style="font-weight:bold; color:#FFD700;">ğŸ† Â¡GANADOR DE LA SUBASTA! ğŸ†</div>
                    <div>${ganador.usuario}</div>
                    <div style="font-size:1.2em;">${ganador.cantidad} ğŸª™</div>
                </div>
            </div>
        `;

        document.body.appendChild(container);

        // 3ï¸âƒ£ Quitar banner despuÃ©s de 10 segundos
        setTimeout(() => {
            container.style.transition = "opacity 0.5s ease";
            container.style.opacity = "0";
            setTimeout(() => {
                container.remove();
                socket.emit("limpiar_listas");
            }, 500);
        }, 10000);
    }
});
// **Y luego, tu listener debe estar despuÃ©s de la declaraciÃ³n:**
socket.on("update_participantes", (listaActualizada) => {
    // Sobrescribir la variable global declarada arriba
    participantes = listaActualizada; 
    
    // Llamar a la funciÃ³n
    actualizarParticipantesUI(); 
});
/* AnimaciÃ³n del popup */
const style = document.createElement("style");
style.innerHTML = `
@keyframes popIn {
  0% { transform: scale(0.8); opacity: 0; }
  100% { transform: scale(1); opacity: 1; }
}`;
document.head.appendChild(style);
// Widget (Cliente) - RecepciÃ³n de eventos del Dashboard
socket.on("activar_alerta_snipe_visual", () => {
    // Cuando el Dashboard dice que el Snipe comenzÃ³, activamos la bandera visual
    isSnipeModeVisual = true;
});
// CÃ“DIGO EN EL CLIENTE/WIDGET (donde manejas el socket.on)

socket.on("desactivar_alerta_snipe_visual", () => {
    // 1. Quitar la clase CSS que pone el color rojo al tiempo
    document.body.classList.remove('snipe-alert'); 
    
    // 2. Opcional: Limpiar o restaurar el texto que dice "Tiempo por delay de live"
    const subtextElWidget = document.getElementById('subtext-tiempo'); // O el ID que uses para ese texto
    if (subtextElWidget) {
        subtextElWidget.textContent = 'Tiempo por delay de live'; // O el texto original
    }
});
socket.on('finalizar_subasta', () => {
    // Cuando la subasta termina, la bandera se apaga (ademÃ¡s de la limpieza)
    isSnipeModeVisual = false; 
    
    // Y hacemos la limpieza final del cuerpo para volver a amarillo
    document.body.classList.remove('snipe-alert');
    const subtextElWidget = document.getElementById('subtext-widget');
    if (subtextElWidget) subtextElWidget.textContent = "El sorteo/subasta termina en";
});
document.addEventListener("DOMContentLoaded", () => {
    const params = new URLSearchParams(window.location.search);
    
    if (params.has("streamerId")) {
        // ğŸŸ¡ Modo widget activado
        document.body.classList.add("widget-mode");
        console.log("ğŸŸ¡ Widget mode activo â€” solo se mostrarÃ¡ el overlay.");
    } else {
        console.log("ğŸŸ¢ Dashboard normal.");
    }
});
    </script>
</body>
</html>

